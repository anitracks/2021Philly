\hypertarget{namespacecleanPlaintiffs}{}\doxysection{clean\+Plaintiffs Namespace Reference}
\label{namespacecleanPlaintiffs}\index{cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{namespacecleanPlaintiffs_a171a230e7ac7699beed794eeeba8bf95}{get\+\_\+class\+\_\+that\+\_\+defined\+\_\+method}} (meth)
\begin{DoxyCompactList}\small\item\em from \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespacecleanPlaintiffs_a0eb434aa5d35772dde9c7944d92a1030}{clean\+Plaintiff}} (full\+Plaintiff)
\begin{DoxyCompactList}\small\item\em Removes everything from LLC or comma to the end of the name. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespacecleanPlaintiffs_a27eb4357cf84539049992715d5187128}{similar\+Name\+List}} (test\+Name, match\+List, compare\+\_\+function, cutoff=90, n\+Returned=50)
\begin{DoxyCompactList}\small\item\em Returns a list of names similar to test\+Name from the match\+List whose match value is $>$= cutoff and returns no more than n\+Returned matches. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespacecleanPlaintiffs_adda46272dbe4ad37a680fd5646edd41d}{test\+Comparison\+Method}} (series\+To\+Test, test\+Function, number\+To\+Try)
\begin{DoxyCompactList}\small\item\em Runs a test on a comparison method to estimate the total time required to run it on the full dataset. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespacecleanPlaintiffs_acef3ec054670e0fcc017786ec1e8aeeb}{create\+Similarity\+Matrix}} (cleaned\+Value\+Counts)
\begin{DoxyCompactList}\small\item\em Taking the cleaned\+Value\+Count from plaintiff\+List, this function creates a similarity matrix between the cleaned names. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespacecleanPlaintiffs_ac95f78e00ae5ea7f5d4f292d6880844e}{plaintiff\+List}} (df, field\+Name)
\begin{DoxyCompactList}\small\item\em Returns df with added column of cleaned plaintiff names. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespacecleanPlaintiffs_a948656ff65ed15ab0295c64a3a2b2311}{dbscan\+Fit}} (fname, eps, min\+\_\+samples=2)
\begin{DoxyCompactList}\small\item\em Runs DBSCAN clustering on the similarity matrix in fname with epsilon (eps) set to eps and clusters requiring at least min\+\_\+samples in them. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespacecleanPlaintiffs_aa52ac5b007acdb249f0fe759a98fa1de}{find\+Base\+Names}} (fname, cutoff=0.\+9)
\begin{DoxyCompactList}\small\item\em Finds the base name of each cleaned name This method does not work as of 2021 May 12. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespacecleanPlaintiffs_ae505e4677480e7908bdd4bcb9c50bf19}{main}} ()
\begin{DoxyCompactList}\small\item\em This is the main function that reads in a csv file containing the court data from the filename passed as the first command line argument. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacecleanPlaintiffs_a5ad72ac922195745aebb519e49a2e29a}{cleanco\+\_\+terms}} = prepare\+\_\+terms()
\item 
list \mbox{\hyperlink{namespacecleanPlaintiffs_aea67d0a19052e0460fa4e622f0d7c759}{stopwords}} = \mbox{[}\textquotesingle{}a\textquotesingle{}, \textquotesingle{}an\textquotesingle{}, \textquotesingle{}the\textquotesingle{}, \textquotesingle{}are\textquotesingle{}\mbox{]}
\item 
\mbox{\hyperlink{namespacecleanPlaintiffs_ac63f3c02b3a437acefd06b2a74572edd}{llc\+Match}} = re.\+compile(r\textquotesingle{}(llc$\vert$,$\vert$a/s/o$\vert$as subrogee of$\vert$\textbackslash{}saso\textbackslash{}s).$\ast$\textquotesingle{}, re.\+I)
\begin{DoxyCompactList}\small\item\em match up to case insensitive first LLC or first comma \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacecleanPlaintiffs_a6b8aa5b6928db0f01e2477455b672597}{alpha\+Match}} = re.\+compile(r\textquotesingle{}\mbox{[}$^\wedge$a-\/z A-\/Z0-\/9\mbox{]}\textquotesingle{})
\begin{DoxyCompactList}\small\item\em clean all non-\/alpha and space characters out \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacecleanPlaintiffs_a55df444f6d816fd4a2beebcc6b097a29}{end\+Caps}} = re.\+compile(r\textquotesingle{}(\textbackslash{}b(?\+:\mbox{[}A-\/Z\mbox{]}+)\textbackslash{}b(?\+:\textbackslash{}s\mbox{[}A-\/Z\mbox{]}+\textbackslash{}b)$\ast$\textbackslash{}.$\ast$)\$\textquotesingle{})
\begin{DoxyCompactList}\small\item\em matches all caps words to the end of the line \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacecleanPlaintiffs_a2520fa4be7522d0231ab7ac252d6579b}{datetime\+To\+End}} = re.\+compile(r\textquotesingle{}(\textbackslash{}s\textbackslash{}d\{1,2\}/\textbackslash{}d\{1,2\}/\textbackslash{}d\{4\} \textbackslash{}d\{1,2\}\+:\textbackslash{}d\{2\} \mbox{[}AP\mbox{]}M.$\ast$)\$\textquotesingle{})
\begin{DoxyCompactList}\small\item\em matches date and time to end of line in format 07/17/2017 1\+:15 \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacecleanPlaintiffs_a0eb434aa5d35772dde9c7944d92a1030}\label{namespacecleanPlaintiffs_a0eb434aa5d35772dde9c7944d92a1030}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!cleanPlaintiff@{cleanPlaintiff}}
\index{cleanPlaintiff@{cleanPlaintiff}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{cleanPlaintiff()}{cleanPlaintiff()}}
{\footnotesize\ttfamily def clean\+Plaintiffs.\+clean\+Plaintiff (\begin{DoxyParamCaption}\item[{}]{full\+Plaintiff }\end{DoxyParamCaption})}



Removes everything from LLC or comma to the end of the name. 


\begin{DoxyParams}{Parameters}
{\em full\+Plaintiff} & is the whole plaintiff name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cleaned string 
\end{DoxyReturn}


Definition at line 97 of file clean\+Plaintiffs.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{97 \textcolor{keyword}{def }\mbox{\hyperlink{namespacecleanPlaintiffs_a0eb434aa5d35772dde9c7944d92a1030}{cleanPlaintiff}}(fullPlaintiff):}
\DoxyCodeLine{98     \textcolor{stringliteral}{"{}"{}"{}! Removes everything from LLC or comma to the end of the name}}
\DoxyCodeLine{99 \textcolor{stringliteral}{       @param fullPlaintiff is the whole plaintiff name}}
\DoxyCodeLine{100 \textcolor{stringliteral}{       @returns cleaned string}}
\DoxyCodeLine{101 \textcolor{stringliteral}{    "{}"{}"{}}}
\DoxyCodeLine{102     }
\DoxyCodeLine{104     if(isinstance(fullPlaintiff, float)):}
\DoxyCodeLine{105         if(math.isnan(fullPlaintiff)):}
\DoxyCodeLine{106             return(\textcolor{stringliteral}{'Blank or NULL'})}
\DoxyCodeLine{107         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{108             pdb.set\_trace()  \textcolor{comment}{\# it isn't an expected value}}
\DoxyCodeLine{109     \textcolor{keywordflow}{try}:}
\DoxyCodeLine{110         cleanedString = llcMatch.sub(\textcolor{stringliteral}{''}, fullPlaintiff).strip()}
\DoxyCodeLine{111     \textcolor{keywordflow}{except} TypeError \textcolor{keyword}{as} e:}
\DoxyCodeLine{112         pdb.set\_trace()  \textcolor{comment}{\# unexpected type}}
\DoxyCodeLine{113     }
\DoxyCodeLine{114     cleanco\_name = basename(cleanedString, cleanco\_terms, prefix=\textcolor{keyword}{False}, middle=\textcolor{keyword}{False}, suffix=\textcolor{keyword}{True})}
\DoxyCodeLine{115     \textcolor{keywordflow}{if} cleanco\_name == \textcolor{stringliteral}{''}:}
\DoxyCodeLine{116         cleanco\_name = cleanedString}
\DoxyCodeLine{117         print(f\textcolor{stringliteral}{"{}cleanco failed on: \{cleanedString\}"{}})}
\DoxyCodeLine{118     }
\DoxyCodeLine{119     cleanedOut = alphaMatch.sub(\textcolor{stringliteral}{''}, cleanco\_name).strip().upper()}
\DoxyCodeLine{120     if(cleanedOut == \textcolor{stringliteral}{''}):}
\DoxyCodeLine{121         print(\textcolor{stringliteral}{'blank output'})}
\DoxyCodeLine{122         pdb.set\_trace()}
\DoxyCodeLine{123     return(cleanedOut)}
\DoxyCodeLine{124 }
\DoxyCodeLine{125 }

\end{DoxyCode}
\mbox{\Hypertarget{namespacecleanPlaintiffs_acef3ec054670e0fcc017786ec1e8aeeb}\label{namespacecleanPlaintiffs_acef3ec054670e0fcc017786ec1e8aeeb}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!createSimilarityMatrix@{createSimilarityMatrix}}
\index{createSimilarityMatrix@{createSimilarityMatrix}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{createSimilarityMatrix()}{createSimilarityMatrix()}}
{\footnotesize\ttfamily def clean\+Plaintiffs.\+create\+Similarity\+Matrix (\begin{DoxyParamCaption}\item[{}]{cleaned\+Value\+Counts }\end{DoxyParamCaption})}



Taking the cleaned\+Value\+Count from plaintiff\+List, this function creates a similarity matrix between the cleaned names. 


\begin{DoxyParams}{Parameters}
{\em cleaned\+Value\+Counts} & returned by plaintiff\+List \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Name of pickle file similarity matrix is saved in 
\end{DoxyReturn}


Definition at line 161 of file clean\+Plaintiffs.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{161 \textcolor{keyword}{def }\mbox{\hyperlink{namespacecleanPlaintiffs_acef3ec054670e0fcc017786ec1e8aeeb}{createSimilarityMatrix}}(cleanedValueCounts):}
\DoxyCodeLine{162     \textcolor{stringliteral}{"{}"{}"{}! Taking the cleanedValueCount from plaintiffList, this }}
\DoxyCodeLine{163 \textcolor{stringliteral}{    function creates a similarity matrix between the cleaned names}}
\DoxyCodeLine{164 \textcolor{stringliteral}{    @param cleanedValueCounts returned by plaintiffList}}
\DoxyCodeLine{165 \textcolor{stringliteral}{    @returns Name of pickle file similarity matrix is saved in}}
\DoxyCodeLine{166 \textcolor{stringliteral}{    "{}"{}"{}}}
\DoxyCodeLine{167     \textcolor{comment}{\# vectorizer = TfidfVectorizer(stop\_words=\{'english'\})}}
\DoxyCodeLine{168     \textcolor{comment}{\# X = vectorizer.fit\_transform(df['Plaintiff Name(s)'])}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170     \textcolor{comment}{\# create list of lists of similar names}}
\DoxyCodeLine{171     \textcolor{comment}{\# do quick histogram analysis of lengths of lists to get an idea}}
\DoxyCodeLine{172     \textcolor{comment}{\# of what is left to do}}
\DoxyCodeLine{173 }
\DoxyCodeLine{174     \textcolor{comment}{\# cutoff = 90  \#\# Percent match has to be >= to this}}
\DoxyCodeLine{175     \textcolor{comment}{\# nReturned = None  \#\# number of matches to return}}
\DoxyCodeLine{176 }
\DoxyCodeLine{177     }
\DoxyCodeLine{187 }
\DoxyCodeLine{188     startTime = datetime.datetime.now()}
\DoxyCodeLine{189     print(f\textcolor{stringliteral}{"{}Started at \{startTime\}"{}})}
\DoxyCodeLine{190     }
\DoxyCodeLine{193     similarNames = cleanedValueCounts.index.to\_series().apply(similarNameList, \(\backslash\)}
\DoxyCodeLine{194         args=(cleanedValueCounts.index.to\_series(), jellyfish.jaro\_similarity))}
\DoxyCodeLine{195     endTime = datetime.datetime.now()}
\DoxyCodeLine{196     totalTime = endTime -\/ startTime}
\DoxyCodeLine{197     print(f\textcolor{stringliteral}{"{}similarNameList took \{totalTime\} seconds"{}})}
\DoxyCodeLine{198 }
\DoxyCodeLine{199     fname = f\textcolor{stringliteral}{"{}\{endTime:\%Y\%m\%d\%H\%M\%S\}-\/comparisonMatrix.pkl"{}}}
\DoxyCodeLine{200     \textcolor{comment}{\# saving Pandas dataframes:}}
\DoxyCodeLine{201     \textcolor{comment}{\# https://towardsdatascience.com/the-\/best-\/format-\/to-\/save-\/pandas-\/data-\/414dca023e0d}}
\DoxyCodeLine{202     similarNames.to\_pickle(fname)}
\DoxyCodeLine{203     }
\DoxyCodeLine{204     \textcolor{comment}{\#  Elbow method of determining how many means to use}}
\DoxyCodeLine{205     \textcolor{comment}{\# Sum\_of\_squared\_distances = []}}
\DoxyCodeLine{206     \textcolor{comment}{\# K = range(2,5)}}
\DoxyCodeLine{207     \textcolor{comment}{\# for k in K:}}
\DoxyCodeLine{208     \textcolor{comment}{\#     print(f"{}Trying \{k\} means"{})}}
\DoxyCodeLine{209     \textcolor{comment}{\#     km = KMeans(n\_clusters=k, max\_iter=200, n\_init=10)}}
\DoxyCodeLine{210     \textcolor{comment}{\#     km = km.fit(X)}}
\DoxyCodeLine{211     \textcolor{comment}{\#     Sum\_of\_squared\_distances.append(km.inertia\_)}}
\DoxyCodeLine{212     \textcolor{comment}{\# plt.plot(K, Sum\_of\_squared\_distances, 'bx-\/')}}
\DoxyCodeLine{213     \textcolor{comment}{\# plt.xlabel('k')}}
\DoxyCodeLine{214     \textcolor{comment}{\# plt.ylabel('Sum\_of\_squared\_distances')}}
\DoxyCodeLine{215     \textcolor{comment}{\# plt.title('Elbow Method For Optimal k')}}
\DoxyCodeLine{216     \textcolor{comment}{\# plt.show()}}
\DoxyCodeLine{217     \textcolor{keywordflow}{return} fname}
\DoxyCodeLine{218 }
\DoxyCodeLine{219 }

\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecleanPlaintiffs_acef3ec054670e0fcc017786ec1e8aeeb_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecleanPlaintiffs_a948656ff65ed15ab0295c64a3a2b2311}\label{namespacecleanPlaintiffs_a948656ff65ed15ab0295c64a3a2b2311}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!dbscanFit@{dbscanFit}}
\index{dbscanFit@{dbscanFit}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{dbscanFit()}{dbscanFit()}}
{\footnotesize\ttfamily def clean\+Plaintiffs.\+dbscan\+Fit (\begin{DoxyParamCaption}\item[{}]{fname,  }\item[{}]{eps,  }\item[{}]{min\+\_\+samples = {\ttfamily 2} }\end{DoxyParamCaption})}



Runs DBSCAN clustering on the similarity matrix in fname with epsilon (eps) set to eps and clusters requiring at least min\+\_\+samples in them. 


\begin{DoxyParams}{Parameters}
{\em fname} & The filename for a pickle file containing a similarity matrix \\
\hline
{\em eps} & Epsilon -\/ the largest distance allowed to be considered a neighbor \\
\hline
{\em min\+\_\+samples} & The minimum number of names in a cluster \\
\hline
\end{DoxyParams}


Definition at line 244 of file clean\+Plaintiffs.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{244 \textcolor{keyword}{def }\mbox{\hyperlink{namespacecleanPlaintiffs_a948656ff65ed15ab0295c64a3a2b2311}{dbscanFit}}(fname, eps, min\_samples=2):}
\DoxyCodeLine{245     \textcolor{stringliteral}{"{}"{}"{}! Runs DBSCAN clustering on the similarity matrix in fname}}
\DoxyCodeLine{246 \textcolor{stringliteral}{    with epsilon (eps) set to eps and clusters requiring at least}}
\DoxyCodeLine{247 \textcolor{stringliteral}{    min\_samples in them.}}
\DoxyCodeLine{248 \textcolor{stringliteral}{}}
\DoxyCodeLine{249 \textcolor{stringliteral}{    @param fname The filename for a pickle file containing a similarity matrix}}
\DoxyCodeLine{250 \textcolor{stringliteral}{    @param eps Epsilon -\/ the largest distance allowed to be considered a neighbor}}
\DoxyCodeLine{251 \textcolor{stringliteral}{    @param min\_samples The minimum number of names in a cluster}}
\DoxyCodeLine{252 \textcolor{stringliteral}{    "{}"{}"{}}}
\DoxyCodeLine{253     similarNames = pd.read\_pickle(fname)}
\DoxyCodeLine{254     distanceNames = 1 -\/ similarNames}
\DoxyCodeLine{255     dbfit = DBSCAN(eps=eps, min\_samples=min\_samples, metric=\textcolor{stringliteral}{'precomputed'}).fit(distanceNames)}
\DoxyCodeLine{256     \textcolor{keywordflow}{return} dbfit}
\DoxyCodeLine{257 }
\DoxyCodeLine{258 }

\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=339pt]{namespacecleanPlaintiffs_a948656ff65ed15ab0295c64a3a2b2311_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecleanPlaintiffs_aa52ac5b007acdb249f0fe759a98fa1de}\label{namespacecleanPlaintiffs_aa52ac5b007acdb249f0fe759a98fa1de}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!findBaseNames@{findBaseNames}}
\index{findBaseNames@{findBaseNames}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{findBaseNames()}{findBaseNames()}}
{\footnotesize\ttfamily def clean\+Plaintiffs.\+find\+Base\+Names (\begin{DoxyParamCaption}\item[{}]{fname,  }\item[{}]{cutoff = {\ttfamily 0.9} }\end{DoxyParamCaption})}



Finds the base name of each cleaned name This method does not work as of 2021 May 12. 


\begin{DoxyParams}{Parameters}
{\em fname} & The filename of the pickle file created by plaintiff\+List \\
\hline
{\em cutoff} & The cutoff similarity between names to assume are the same \\
\hline
\end{DoxyParams}


Definition at line 259 of file clean\+Plaintiffs.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{259 \textcolor{keyword}{def }\mbox{\hyperlink{namespacecleanPlaintiffs_aa52ac5b007acdb249f0fe759a98fa1de}{findBaseNames}}(fname, cutoff=0.9):}
\DoxyCodeLine{260     \textcolor{stringliteral}{"{}"{}"{}! Finds the base name of each cleaned name}}
\DoxyCodeLine{261 \textcolor{stringliteral}{    This method does not work as of 2021 May 12}}
\DoxyCodeLine{262 \textcolor{stringliteral}{}}
\DoxyCodeLine{263 \textcolor{stringliteral}{    @param fname The filename of the pickle file created by plaintiffList}}
\DoxyCodeLine{264 \textcolor{stringliteral}{    @param cutoff The cutoff similarity between names to assume are the same}}
\DoxyCodeLine{265 \textcolor{stringliteral}{    "{}"{}"{}}}
\DoxyCodeLine{266     similarNames = pd.read\_pickle(fname)}
\DoxyCodeLine{267     test1 = similarNames.apply(\textcolor{keyword}{lambda} x: x > cutoff)}
\DoxyCodeLine{268     seenNames = set()  \textcolor{comment}{\# set of names already processed}}
\DoxyCodeLine{269     nameGroups = []  \textcolor{comment}{\# list of name groups}}
\DoxyCodeLine{270     startTime = datetime.datetime.now()}
\DoxyCodeLine{271     print(f\textcolor{stringliteral}{'Starting the collation at \{startTime\}'})}
\DoxyCodeLine{272     \textcolor{keywordflow}{for} name \textcolor{keywordflow}{in} test1.index:}
\DoxyCodeLine{273         \textcolor{keywordflow}{if} name \textcolor{keywordflow}{not} \textcolor{keywordflow}{in} seenNames:}
\DoxyCodeLine{274             checkNamesSet = test1[test1[name] == \textcolor{keyword}{True}].index}
\DoxyCodeLine{275             closeNamesSet = set(checkNamesSet)}
\DoxyCodeLine{276             seenNames.add(name)}
\DoxyCodeLine{277             \textcolor{keywordflow}{for} check \textcolor{keywordflow}{in} checkNamesSet:}
\DoxyCodeLine{278                 \textcolor{keywordflow}{if} check \textcolor{keywordflow}{not} \textcolor{keywordflow}{in} seenNames:}
\DoxyCodeLine{279                     moreNames = test1[test1[check] == \textcolor{keyword}{True}].index}
\DoxyCodeLine{280                     seenNames.add(check)}
\DoxyCodeLine{281                     closeNamesSet.update(moreNames)}
\DoxyCodeLine{282             nameGroups.append(closeNamesSet)}
\DoxyCodeLine{283     stopTime = datetime.datetime.now()}
\DoxyCodeLine{284     print(f\textcolor{stringliteral}{'took \{stopTime -\/ startTime\} seconds'})}
\DoxyCodeLine{285     pdb.set\_trace()}
\DoxyCodeLine{286     return(nameGroups)}
\DoxyCodeLine{287 }
\DoxyCodeLine{288     \textcolor{comment}{\# closeNames = test1[test1['MIDLAND FUNDING'] == True].index.to\_series()}}
\DoxyCodeLine{289     \textcolor{comment}{\# closeNamesSet = set(test1[test1['MIDLAND FUNDING'] == True].index) }}
\DoxyCodeLine{290     \textcolor{comment}{\# for name in closeNamesSet:}}
\DoxyCodeLine{291     \textcolor{comment}{\#     moreNames = set(test1[test1[name] == True].index)}}
\DoxyCodeLine{292     \textcolor{comment}{\#     closeNamesSet = closeNamesSet.union(moreNames)}}
\DoxyCodeLine{293     \textcolor{comment}{\# pdb.set\_trace()}}
\DoxyCodeLine{294 }
\DoxyCodeLine{295 }

\end{DoxyCode}
\mbox{\Hypertarget{namespacecleanPlaintiffs_a171a230e7ac7699beed794eeeba8bf95}\label{namespacecleanPlaintiffs_a171a230e7ac7699beed794eeeba8bf95}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!get\_class\_that\_defined\_method@{get\_class\_that\_defined\_method}}
\index{get\_class\_that\_defined\_method@{get\_class\_that\_defined\_method}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{get\_class\_that\_defined\_method()}{get\_class\_that\_defined\_method()}}
{\footnotesize\ttfamily def clean\+Plaintiffs.\+get\+\_\+class\+\_\+that\+\_\+defined\+\_\+method (\begin{DoxyParamCaption}\item[{}]{meth }\end{DoxyParamCaption})}



from 



Definition at line 80 of file clean\+Plaintiffs.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{80 \textcolor{keyword}{def }\mbox{\hyperlink{namespacecleanPlaintiffs_a171a230e7ac7699beed794eeeba8bf95}{get\_class\_that\_defined\_method}}(meth):}
\DoxyCodeLine{81     \textcolor{stringliteral}{"{}"{}"{}! from }}
\DoxyCodeLine{82 \textcolor{stringliteral}{    "{}"{}"{}}}
\DoxyCodeLine{83     \textcolor{keywordflow}{if} inspect.ismethod(meth) \textcolor{keywordflow}{or} (inspect.isbuiltin(meth) \textcolor{keywordflow}{and} getattr(meth, \textcolor{stringliteral}{'\_\_self\_\_'}, \textcolor{keywordtype}{None}) \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} getattr(meth.\_\_self\_\_, \textcolor{stringliteral}{'\_\_class\_\_'}, \textcolor{keywordtype}{None})):}
\DoxyCodeLine{84         \textcolor{keywordflow}{for} cls \textcolor{keywordflow}{in} inspect.getmro(meth.\_\_self\_\_.\_\_class\_\_):}
\DoxyCodeLine{85             \textcolor{keywordflow}{if} meth.\_\_name\_\_ \textcolor{keywordflow}{in} cls.\_\_dict\_\_:}
\DoxyCodeLine{86                 \textcolor{keywordflow}{return} cls}
\DoxyCodeLine{87         meth = getattr(meth, \textcolor{stringliteral}{'\_\_func\_\_'}, meth)  \textcolor{comment}{\# fallback to \_\_qualname\_\_ parsing}}
\DoxyCodeLine{88     \textcolor{keywordflow}{if} inspect.isfunction(meth):}
\DoxyCodeLine{89         cls = getattr(inspect.getmodule(meth),}
\DoxyCodeLine{90                       meth.\_\_qualname\_\_.split(\textcolor{stringliteral}{'.<locals>'}, 1)[0].rsplit(\textcolor{stringliteral}{'.'}, 1)[0],}
\DoxyCodeLine{91                       \textcolor{keywordtype}{None})}
\DoxyCodeLine{92         \textcolor{keywordflow}{if} isinstance(cls, type):}
\DoxyCodeLine{93             \textcolor{keywordflow}{return} cls}
\DoxyCodeLine{94     \textcolor{keywordflow}{return} getattr(meth, \textcolor{stringliteral}{'\_\_objclass\_\_'}, \textcolor{keywordtype}{None})  \textcolor{comment}{\# handle special descriptor objects}}
\DoxyCodeLine{95 }
\DoxyCodeLine{96 }

\end{DoxyCode}
\mbox{\Hypertarget{namespacecleanPlaintiffs_ae505e4677480e7908bdd4bcb9c50bf19}\label{namespacecleanPlaintiffs_ae505e4677480e7908bdd4bcb9c50bf19}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!main@{main}}
\index{main@{main}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{main()}{main()}}
{\footnotesize\ttfamily def clean\+Plaintiffs.\+main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



This is the main function that reads in a csv file containing the court data from the filename passed as the first command line argument. 

It then prints out the column names for reference, filters out the duplicate rows, and prints out the column types for reference. It also calculates the median judgement amount as a proof of concept. Lastly, it calls outcome\+List to create a cleaned and counted list of the outcomes and prints the results. 

Definition at line 296 of file clean\+Plaintiffs.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{296 \textcolor{keyword}{def }\mbox{\hyperlink{namespacecleanPlaintiffs_ae505e4677480e7908bdd4bcb9c50bf19}{main}}():}
\DoxyCodeLine{297     \textcolor{stringliteral}{"{}"{}"{}! This is the main function that reads in a csv file containing the}}
\DoxyCodeLine{298 \textcolor{stringliteral}{    court data from the filename passed as the first command line argument. }}
\DoxyCodeLine{299 \textcolor{stringliteral}{    It then prints out the column names for reference, filters out the}}
\DoxyCodeLine{300 \textcolor{stringliteral}{    duplicate rows, and prints out the column types for reference. It also}}
\DoxyCodeLine{301 \textcolor{stringliteral}{    calculates the median judgement amount as a proof of concept. Lastly,}}
\DoxyCodeLine{302 \textcolor{stringliteral}{    it calls outcomeList to create a cleaned and counted list of the outcomes}}
\DoxyCodeLine{303 \textcolor{stringliteral}{    and prints the results.}}
\DoxyCodeLine{304 \textcolor{stringliteral}{    "{}"{}"{}}}
\DoxyCodeLine{305     parser = argparse.ArgumentParser(description=\_\_doc\_\_, fromfile\_prefix\_chars=\textcolor{stringliteral}{'@'})}
\DoxyCodeLine{306     parser.add\_argument(\textcolor{stringliteral}{'csvfile'}, help=\textcolor{stringliteral}{'The name of the csv file to load'})}
\DoxyCodeLine{307     parser.add\_argument(\textcolor{stringliteral}{'-\/p'}, \textcolor{stringliteral}{'-\/-\/picklefile'}, help=\textcolor{stringliteral}{'The name of the pickle file to load'})}
\DoxyCodeLine{308 \textcolor{comment}{\#    parser.add\_argument('-\/c', '-\/-\/cutoff', help='The cutoff for similarity checking', type=float)}}
\DoxyCodeLine{309     parser.add\_argument(\textcolor{stringliteral}{'-\/e'}, \textcolor{stringliteral}{'-\/-\/eps'}, help=\textcolor{stringliteral}{'The neighbor distance setting for DBSCAN'}, type=float)}
\DoxyCodeLine{310     parser.add\_argument(\textcolor{stringliteral}{'-\/s'}, \textcolor{stringliteral}{'-\/-\/similarity'}, action=\textcolor{stringliteral}{'store\_true'}, help=\textcolor{stringliteral}{'Do similarity calculations'})}
\DoxyCodeLine{311 }
\DoxyCodeLine{312     start\_time = datetime.datetime.now()  \textcolor{comment}{\# save the time the script started}}
\DoxyCodeLine{313     args = parser.parse\_args()  \textcolor{comment}{\# parse the command line arguments}}
\DoxyCodeLine{314 }
\DoxyCodeLine{315     \textcolor{comment}{\# Plaintiff Attorney ID and Defendant Attorney ID come in as mixed types for some reason}}
\DoxyCodeLine{316     csvDF = pd.read\_csv(args.csvfile)  \textcolor{comment}{\# read in the csv data}}
\DoxyCodeLine{317     \textcolor{comment}{\# print(f'The column names are:\(\backslash\)n\{csvDF.columns.values\}')}}
\DoxyCodeLine{318 }
\DoxyCodeLine{319     df = \mbox{\hyperlink{namespacecleanCountOutcomes_a4274f083552a8e34e4f1100d27302ef2}{cleanCountOutcomes.removeDuplicates}}(csvDF)}
\DoxyCodeLine{320     (cleanedValueCounts, df) = \mbox{\hyperlink{namespacecleanPlaintiffs_ac95f78e00ae5ea7f5d4f292d6880844e}{plaintiffList}}(df, \textcolor{stringliteral}{'Plaintiff Name(s)'})}
\DoxyCodeLine{321     (outcomes, df) = \mbox{\hyperlink{namespacecleanCountOutcomes_a5293171c9a56b78cc70e003c9817e261}{cleanCountOutcomes.outcomeList}}(df, \textcolor{stringliteral}{'Case Outcome'})}
\DoxyCodeLine{322 }
\DoxyCodeLine{323     \textcolor{keywordflow}{if} args.similarity:  \textcolor{comment}{\# create the similarity matrix. Takes hours to calculate}}
\DoxyCodeLine{324         pickleFileName = \mbox{\hyperlink{namespacecleanPlaintiffs_acef3ec054670e0fcc017786ec1e8aeeb}{createSimilarityMatrix}}(cleanedValueCounts)}
\DoxyCodeLine{325     \textcolor{keywordflow}{elif} args.picklefile:}
\DoxyCodeLine{326         pickleFileName = args.picklefile}
\DoxyCodeLine{327     \textcolor{keywordflow}{else}:}
\DoxyCodeLine{328         \textcolor{keywordflow}{raise} Exception(\textcolor{stringliteral}{"{}Need to either pass the -\/s flag or the -\/p with pickle file name"{}})}
\DoxyCodeLine{329     }
\DoxyCodeLine{330     print(f\textcolor{stringliteral}{'Using \{pickleFileName\} for similarity matrix'})}
\DoxyCodeLine{331 }
\DoxyCodeLine{332     \textcolor{keywordflow}{if} args.eps:}
\DoxyCodeLine{333         eps = args.eps}
\DoxyCodeLine{334     \textcolor{keywordflow}{else}:}
\DoxyCodeLine{335         eps = 0.1}
\DoxyCodeLine{336     dbfit = \mbox{\hyperlink{namespacecleanPlaintiffs_a948656ff65ed15ab0295c64a3a2b2311}{dbscanFit}}(pickleFileName, eps)}
\DoxyCodeLine{337     similarNames = pd.read\_pickle(pickleFileName)}
\DoxyCodeLine{338     distanceNames = 1 -\/ similarNames}
\DoxyCodeLine{339 }
\DoxyCodeLine{340     \textcolor{comment}{\# print('\(\backslash\)nPlaintiff Frequency')}}
\DoxyCodeLine{341     \textcolor{comment}{\# print(f'\{plaintiffs\}')}}
\DoxyCodeLine{342     \textcolor{comment}{\# for plaintiff, pCount in plaintiffs.items():}}
\DoxyCodeLine{343     \textcolor{comment}{\#     if(pCount > 10):}}
\DoxyCodeLine{344     \textcolor{comment}{\#         print(f"{}\{plaintiff\},\{pCount\}"{})}}
\DoxyCodeLine{345 }
\DoxyCodeLine{346     \textcolor{comment}{\# data we have}}
\DoxyCodeLine{347     clusterSet = set(dbfit.labels\_)}
\DoxyCodeLine{348     \textcolor{comment}{\# clusterSet.discard(-\/1)  \# discard the "{}noise"{} names}}
\DoxyCodeLine{349     clusterNameLists = []}
\DoxyCodeLine{350     \textcolor{keywordflow}{for} clust \textcolor{keywordflow}{in} clusterSet:}
\DoxyCodeLine{351         clusterNameLists.append(distanceNames.index[dbfit.labels\_ == clust])}
\DoxyCodeLine{352     clusterDF = pd.DataFrame(clusterNameLists)  \textcolor{comment}{\# each row is list of names in cluster}}
\DoxyCodeLine{353     }
\DoxyCodeLine{354     df  \textcolor{comment}{\# whole dataset with cleaned plaintiff and outcomes}}
\DoxyCodeLine{355     dbfit.labels\_  \textcolor{comment}{\# cluster number for cleanedPlaintiff}}
\DoxyCodeLine{356     df.iloc[0][\textcolor{stringliteral}{'PlaintiffCleaned'}]  \textcolor{comment}{\# Need to know what group this is in}}
\DoxyCodeLine{357     df.iloc[0][\textcolor{stringliteral}{'OutcomeCleaned'}]}
\DoxyCodeLine{358 }
\DoxyCodeLine{359     df[\textcolor{stringliteral}{'ClusterNum'}] = -\/5  \textcolor{comment}{\# set clusterNum to an invalid number to make sure all get changed}}
\DoxyCodeLine{360     df[\textcolor{stringliteral}{'ClusterName'}] = \textcolor{stringliteral}{'ZZ-\/Unclustered'}  \textcolor{comment}{\# set clusterNum to an invalid number to make sure all get changed}}
\DoxyCodeLine{361     maxClusterIndex = max(clusterDF.index)  \textcolor{comment}{\# store off max index for use later}}
\DoxyCodeLine{362     clusterDF.insert(0, \textcolor{stringliteral}{'Count'}, -\/1)  \textcolor{comment}{\# set count to an invalid number to allow checking}}
\DoxyCodeLine{363     clusterNames = []  \textcolor{comment}{\# list of cluster names}}
\DoxyCodeLine{364     \textcolor{comment}{\# Set the cluster number for each entry in df}}
\DoxyCodeLine{365     \textcolor{keywordflow}{for} ind \textcolor{keywordflow}{in} clusterDF.index:}
\DoxyCodeLine{366         rowIndexer = df[\textcolor{stringliteral}{'PlaintiffCleaned'}].isin(clusterDF.iloc[ind])}
\DoxyCodeLine{367         clusterDF.loc[ind,\textcolor{stringliteral}{'Count'}] = len(df.loc[rowIndexer,\textcolor{stringliteral}{'ClusterNum'}])}
\DoxyCodeLine{368         if(ind != maxClusterIndex):}
\DoxyCodeLine{369             df.loc[rowIndexer,\textcolor{stringliteral}{'ClusterNum'}] = ind}
\DoxyCodeLine{370             df.loc[rowIndexer, \textcolor{stringliteral}{'ClusterName'}] = df.loc[rowIndexer, \textcolor{stringliteral}{'PlaintiffCleaned'}].mode()[0]}
\DoxyCodeLine{371             clusterNames.append(df.loc[rowIndexer, \textcolor{stringliteral}{'PlaintiffCleaned'}].mode()[0])}
\DoxyCodeLine{372         \textcolor{keywordflow}{else}:  \textcolor{comment}{\# set the catchall/not in cluster values to -\/1}}
\DoxyCodeLine{373             df.loc[df[\textcolor{stringliteral}{'PlaintiffCleaned'}].isin(clusterDF.iloc[ind]),\textcolor{stringliteral}{'ClusterNum'}] = -\/1}
\DoxyCodeLine{374             df.loc[rowIndexer, \textcolor{stringliteral}{'ClusterName'}] = df.loc[rowIndexer, \textcolor{stringliteral}{'PlaintiffCleaned'}]}
\DoxyCodeLine{375 }
\DoxyCodeLine{376     \textcolor{comment}{\# create the comparison matrix}}
\DoxyCodeLine{377     \textcolor{comment}{\# https://stackoverflow.com/questions/48465941/counting-\/combinations-\/between-\/two-\/dataframe-\/columns}}
\DoxyCodeLine{378     time\_now = datetime.datetime.now()}
\DoxyCodeLine{379     comparedPO = pd.crosstab(df[\textcolor{stringliteral}{'ClusterName'}], df[\textcolor{stringliteral}{'OutcomeCleaned'}])  \textcolor{comment}{\# Seems to be a good base dataset}}
\DoxyCodeLine{380     comparedPO.insert(0, \textcolor{stringliteral}{'Clustered'},\textcolor{stringliteral}{'unknown'})}
\DoxyCodeLine{381     comparedPO.loc[comparedPO.index.isin(clusterNames),\textcolor{stringliteral}{'Clustered'}] = \textcolor{keyword}{True}}
\DoxyCodeLine{382     comparedPO.loc[\string~comparedPO.index.isin(clusterNames),\textcolor{stringliteral}{'Clustered'}] = \textcolor{keyword}{False}}
\DoxyCodeLine{383     comparedPO.to\_csv(f\textcolor{stringliteral}{'\{time\_now:\%Y\%m\%d\%H\%M\%S\}-\/comparedPO.csv'})}
\DoxyCodeLine{384 }
\DoxyCodeLine{385     stop\_time = datetime.datetime.now()}
\DoxyCodeLine{386     print(f\textcolor{stringliteral}{'\{\_\_file\_\_\} took \{stop\_time-\/start\_time\} seconds so far'})}
\DoxyCodeLine{387     \textcolor{comment}{\# the following line counts the Plaintiff names that contain Midland as a check}}
\DoxyCodeLine{388     \textcolor{comment}{\#nMidlands = len(csvNoDups[csvNoDups['Plaintiff Name(s)'].str.contains('Midland', flags=re.IGNORECASE)]['Plaintiff Name(s)'])}}
\DoxyCodeLine{389 }
\DoxyCodeLine{390     stop\_time = datetime.datetime.now()}
\DoxyCodeLine{391     print(f\textcolor{stringliteral}{'\{\_\_file\_\_\} took \{stop\_time-\/start\_time\} seconds'})}
\DoxyCodeLine{392 }

\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecleanPlaintiffs_ae505e4677480e7908bdd4bcb9c50bf19_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecleanPlaintiffs_ac95f78e00ae5ea7f5d4f292d6880844e}\label{namespacecleanPlaintiffs_ac95f78e00ae5ea7f5d4f292d6880844e}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!plaintiffList@{plaintiffList}}
\index{plaintiffList@{plaintiffList}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{plaintiffList()}{plaintiffList()}}
{\footnotesize\ttfamily def clean\+Plaintiffs.\+plaintiff\+List (\begin{DoxyParamCaption}\item[{}]{df,  }\item[{}]{field\+Name }\end{DoxyParamCaption})}



Returns df with added column of cleaned plaintiff names. 


\begin{DoxyParams}{Parameters}
{\em df} & is a panda dataframe of plaintiff names from reading in the csv file of data that has had duplicates removed and other cleaning done \\
\hline
{\em fieldname} & The column name that contains the plaintiff names to be cleaned \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Tuple (cleaned and sorted plaintiff names, df with cleaned plaintiff names column) 
\end{DoxyReturn}


Definition at line 220 of file clean\+Plaintiffs.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{220 \textcolor{keyword}{def }\mbox{\hyperlink{namespacecleanPlaintiffs_ac95f78e00ae5ea7f5d4f292d6880844e}{plaintiffList}}(df, fieldName):}
\DoxyCodeLine{221     \textcolor{stringliteral}{"{}"{}"{}!  Returns df with added column of cleaned plaintiff names}}
\DoxyCodeLine{222 \textcolor{stringliteral}{    @param df is a panda dataframe of plaintiff names from reading in the csv file }}
\DoxyCodeLine{223 \textcolor{stringliteral}{        of data that has had duplicates removed and other cleaning done}}
\DoxyCodeLine{224 \textcolor{stringliteral}{    @param fieldname The column name that contains the plaintiff names to be cleaned}}
\DoxyCodeLine{225 \textcolor{stringliteral}{    @returns Tuple (cleaned and sorted plaintiff names, }}
\DoxyCodeLine{226 \textcolor{stringliteral}{        df with cleaned plaintiff names column)}}
\DoxyCodeLine{227 \textcolor{stringliteral}{    "{}"{}"{}}}
\DoxyCodeLine{228  }
\DoxyCodeLine{229     outcomes = df[fieldName].copy(deep=\textcolor{keyword}{True})}
\DoxyCodeLine{230     \textcolor{comment}{\# clean up the outcome string}}
\DoxyCodeLine{231     cleanedPlaintiffs = outcomes.apply(cleanPlaintiff)}
\DoxyCodeLine{232     \textcolor{comment}{\# add cleaned plaintiff names to the original dataframe}}
\DoxyCodeLine{233     \textcolor{comment}{\# the following line caused a setting copy of slice from dataframe warning}}
\DoxyCodeLine{234     \textcolor{comment}{\# https://www.dataquest.io/blog/settingwithcopywarning/}}
\DoxyCodeLine{235     df = df.assign(PlaintiffCleaned=cleanedPlaintiffs)}
\DoxyCodeLine{236 }
\DoxyCodeLine{237     \textcolor{comment}{\# Good ways to count specific occurances: }}
\DoxyCodeLine{238     \textcolor{comment}{\# https://stackoverflow.com/a/35277776}}
\DoxyCodeLine{239     \textcolor{comment}{\# see also cleanedOutcomes.value\_counts()}}
\DoxyCodeLine{240     cleanedValueCounts = cleanedPlaintiffs.value\_counts()}
\DoxyCodeLine{241     return((cleanedValueCounts, df))}
\DoxyCodeLine{242 }
\DoxyCodeLine{243 }

\end{DoxyCode}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{namespacecleanPlaintiffs_ac95f78e00ae5ea7f5d4f292d6880844e_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecleanPlaintiffs_a27eb4357cf84539049992715d5187128}\label{namespacecleanPlaintiffs_a27eb4357cf84539049992715d5187128}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!similarNameList@{similarNameList}}
\index{similarNameList@{similarNameList}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{similarNameList()}{similarNameList()}}
{\footnotesize\ttfamily def clean\+Plaintiffs.\+similar\+Name\+List (\begin{DoxyParamCaption}\item[{}]{test\+Name,  }\item[{}]{match\+List,  }\item[{}]{compare\+\_\+function,  }\item[{}]{cutoff = {\ttfamily 90},  }\item[{}]{n\+Returned = {\ttfamily 50} }\end{DoxyParamCaption})}



Returns a list of names similar to test\+Name from the match\+List whose match value is $>$= cutoff and returns no more than n\+Returned matches. 


\begin{DoxyParams}{Parameters}
{\em test\+Name} & String to search match \\
\hline
{\em match\+List} & List of names to compare against \\
\hline
{\em cutoff} & The minimum percent match to include in returned list \\
\hline
{\em n\+Returned} & The maximum number of results to return \\
\hline
\end{DoxyParams}


Definition at line 126 of file clean\+Plaintiffs.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{126 \textcolor{keyword}{def }\mbox{\hyperlink{namespacecleanPlaintiffs_a27eb4357cf84539049992715d5187128}{similarNameList}}(testName, matchList, compare\_function, cutoff=90, nReturned=50):}
\DoxyCodeLine{127     \textcolor{stringliteral}{"{}"{}"{}! Returns a list of names similar to testName from the matchList}}
\DoxyCodeLine{128 \textcolor{stringliteral}{    whose match value is >= cutoff and returns no more than nReturned matches}}
\DoxyCodeLine{129 \textcolor{stringliteral}{}}
\DoxyCodeLine{130 \textcolor{stringliteral}{    @param testName String to search match}}
\DoxyCodeLine{131 \textcolor{stringliteral}{    @param matchList List of names to compare against}}
\DoxyCodeLine{132 \textcolor{stringliteral}{    @param cutoff The minimum percent match to include in returned list}}
\DoxyCodeLine{133 \textcolor{stringliteral}{    @param nReturned The maximum number of results to return}}
\DoxyCodeLine{134 \textcolor{stringliteral}{    "{}"{}"{}}}
\DoxyCodeLine{135     comparisons = matchList.apply(compare\_function, args=([testName]))}
\DoxyCodeLine{136     return(comparisons)}
\DoxyCodeLine{137 }
\DoxyCodeLine{138 }

\end{DoxyCode}
\mbox{\Hypertarget{namespacecleanPlaintiffs_adda46272dbe4ad37a680fd5646edd41d}\label{namespacecleanPlaintiffs_adda46272dbe4ad37a680fd5646edd41d}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!testComparisonMethod@{testComparisonMethod}}
\index{testComparisonMethod@{testComparisonMethod}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{testComparisonMethod()}{testComparisonMethod()}}
{\footnotesize\ttfamily def clean\+Plaintiffs.\+test\+Comparison\+Method (\begin{DoxyParamCaption}\item[{}]{series\+To\+Test,  }\item[{}]{test\+Function,  }\item[{}]{number\+To\+Try }\end{DoxyParamCaption})}



Runs a test on a comparison method to estimate the total time required to run it on the full dataset. 


\begin{DoxyParams}{Parameters}
{\em series\+To\+Test} & A Pandas Series object to run the test against \\
\hline
{\em test\+Function} & The text comparison function to try \\
\hline
{\em number\+To\+Try} & The sampling size to run \\
\hline
\end{DoxyParams}


Definition at line 139 of file clean\+Plaintiffs.\+py.


\begin{DoxyCode}{0}
\DoxyCodeLine{139 \textcolor{keyword}{def }\mbox{\hyperlink{namespacecleanPlaintiffs_adda46272dbe4ad37a680fd5646edd41d}{testComparisonMethod}}(seriesToTest, testFunction, numberToTry):}
\DoxyCodeLine{140     \textcolor{stringliteral}{"{}"{}"{}! Runs a test on a comparison method to estimate the total time}}
\DoxyCodeLine{141 \textcolor{stringliteral}{    required to run it on the full dataset}}
\DoxyCodeLine{142 \textcolor{stringliteral}{}}
\DoxyCodeLine{143 \textcolor{stringliteral}{    @param seriesToTest A Pandas Series object to run the test against}}
\DoxyCodeLine{144 \textcolor{stringliteral}{    @param testFunction The text comparison function to try}}
\DoxyCodeLine{145 \textcolor{stringliteral}{    @param numberToTry The sampling size to run}}
\DoxyCodeLine{146 \textcolor{stringliteral}{    "{}"{}"{}}}
\DoxyCodeLine{147     nTest = numberToTry  \textcolor{comment}{\# number of names to test}}
\DoxyCodeLine{148     startTime = datetime.datetime.now()}
\DoxyCodeLine{149     print(f\textcolor{stringliteral}{"{}Starting at \{startTime\}"{}})}
\DoxyCodeLine{150     }
\DoxyCodeLine{153     similarNames = seriesToTest.apply(similarNameList, \(\backslash\)}
\DoxyCodeLine{154         args=(seriesToTest[:nTest], testFunction))}
\DoxyCodeLine{155     totalTime = datetime.datetime.now() -\/ startTime}
\DoxyCodeLine{156     print(f\textcolor{stringliteral}{"{}similarNameList took \{totalTime\} seconds"{}})}
\DoxyCodeLine{157     print(f\textcolor{stringliteral}{"{}Time per name: \{totalTime/nTest\}"{}})}
\DoxyCodeLine{158     print(f\textcolor{stringliteral}{"{}Time estimate for whole table: \{seriesToTest.size*totalTime/nTest\}"{}})}
\DoxyCodeLine{159 }
\DoxyCodeLine{160 }

\end{DoxyCode}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespacecleanPlaintiffs_a6b8aa5b6928db0f01e2477455b672597}\label{namespacecleanPlaintiffs_a6b8aa5b6928db0f01e2477455b672597}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!alphaMatch@{alphaMatch}}
\index{alphaMatch@{alphaMatch}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{alphaMatch}{alphaMatch}}
{\footnotesize\ttfamily clean\+Plaintiffs.\+alpha\+Match = re.\+compile(r\textquotesingle{}\mbox{[}$^\wedge$a-\/z A-\/Z0-\/9\mbox{]}\textquotesingle{})}



clean all non-\/alpha and space characters out 



Definition at line 73 of file clean\+Plaintiffs.\+py.

\mbox{\Hypertarget{namespacecleanPlaintiffs_a5ad72ac922195745aebb519e49a2e29a}\label{namespacecleanPlaintiffs_a5ad72ac922195745aebb519e49a2e29a}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!cleanco\_terms@{cleanco\_terms}}
\index{cleanco\_terms@{cleanco\_terms}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{cleanco\_terms}{cleanco\_terms}}
{\footnotesize\ttfamily clean\+Plaintiffs.\+cleanco\+\_\+terms = prepare\+\_\+terms()}



Definition at line 66 of file clean\+Plaintiffs.\+py.

\mbox{\Hypertarget{namespacecleanPlaintiffs_a2520fa4be7522d0231ab7ac252d6579b}\label{namespacecleanPlaintiffs_a2520fa4be7522d0231ab7ac252d6579b}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!datetimeToEnd@{datetimeToEnd}}
\index{datetimeToEnd@{datetimeToEnd}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{datetimeToEnd}{datetimeToEnd}}
{\footnotesize\ttfamily clean\+Plaintiffs.\+datetime\+To\+End = re.\+compile(r\textquotesingle{}(\textbackslash{}s\textbackslash{}d\{1,2\}/\textbackslash{}d\{1,2\}/\textbackslash{}d\{4\} \textbackslash{}d\{1,2\}\+:\textbackslash{}d\{2\} \mbox{[}AP\mbox{]}M.$\ast$)\$\textquotesingle{})}



matches date and time to end of line in format 07/17/2017 1\+:15 



Definition at line 78 of file clean\+Plaintiffs.\+py.

\mbox{\Hypertarget{namespacecleanPlaintiffs_a55df444f6d816fd4a2beebcc6b097a29}\label{namespacecleanPlaintiffs_a55df444f6d816fd4a2beebcc6b097a29}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!endCaps@{endCaps}}
\index{endCaps@{endCaps}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{endCaps}{endCaps}}
{\footnotesize\ttfamily clean\+Plaintiffs.\+end\+Caps = re.\+compile(r\textquotesingle{}(\textbackslash{}b(?\+:\mbox{[}A-\/Z\mbox{]}+)\textbackslash{}b(?\+:\textbackslash{}s\mbox{[}A-\/Z\mbox{]}+\textbackslash{}b)$\ast$\textbackslash{}.$\ast$)\$\textquotesingle{})}



matches all caps words to the end of the line 



Definition at line 76 of file clean\+Plaintiffs.\+py.

\mbox{\Hypertarget{namespacecleanPlaintiffs_ac63f3c02b3a437acefd06b2a74572edd}\label{namespacecleanPlaintiffs_ac63f3c02b3a437acefd06b2a74572edd}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!llcMatch@{llcMatch}}
\index{llcMatch@{llcMatch}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{llcMatch}{llcMatch}}
{\footnotesize\ttfamily clean\+Plaintiffs.\+llc\+Match = re.\+compile(r\textquotesingle{}(llc$\vert$,$\vert$a/s/o$\vert$as subrogee of$\vert$\textbackslash{}saso\textbackslash{}s).$\ast$\textquotesingle{}, re.\+I)}



match up to case insensitive first LLC or first comma 



Definition at line 71 of file clean\+Plaintiffs.\+py.

\mbox{\Hypertarget{namespacecleanPlaintiffs_aea67d0a19052e0460fa4e622f0d7c759}\label{namespacecleanPlaintiffs_aea67d0a19052e0460fa4e622f0d7c759}} 
\index{cleanPlaintiffs@{cleanPlaintiffs}!stopwords@{stopwords}}
\index{stopwords@{stopwords}!cleanPlaintiffs@{cleanPlaintiffs}}
\doxysubsubsection{\texorpdfstring{stopwords}{stopwords}}
{\footnotesize\ttfamily list clean\+Plaintiffs.\+stopwords = \mbox{[}\textquotesingle{}a\textquotesingle{}, \textquotesingle{}an\textquotesingle{}, \textquotesingle{}the\textquotesingle{}, \textquotesingle{}are\textquotesingle{}\mbox{]}}



Definition at line 68 of file clean\+Plaintiffs.\+py.

